### Q11.5

Modify ```asciiadd.asm``` (Program 11.1) to read two decimal numbers from the user instead of taking them from memory (as in the last exercise). It should then subtract the second number from the first and display the result using ```PutStr```. The two numbers from the user should be read as strings using ```GetStr```.

#### Last Exercise (Q11.4)

Modify ```asciiadd.asm``` (Program 11.1) to read two decimal numbers from the user instead of taking them from memory. The two numbers from the user should be read as strings. You can use ```GetStr``` to read the input numbers.

#### Example: Multidigit ASCII Addition

Addition of multidigit numbers in ASCII representation is done one digit at a time starting with the rightmost digit. To illustrate the process involved, we discuss how addition of two 10-digit numbers is done (see the program listing below).

##### Program 11.1 ASCII addition of two 10-digit numbers

```assembly
1: ;Addition of two integers in ASCII form ASCIIADD.ASM
2: ;
3: ; Objective: To demonstrate addition of two integers
4: ; in the ASCII representation.
5: ; Input: None.
6: ; Output: Displays the sum.
7: %include "io.mac"
8:
9: .DATA
10: sum_msg db ’The sum is: ’,0
11: number1 db ’1234567890’
12: number2 db ’1098765432’
13: sum db ’ ’,0 ; add NULL char. to use PutStr
14:
15: .CODE
16: .STARTUP
17: ; ESI is used as index into number1, number2, and sum
18: mov ESI,9 ; ESI points to rightmost digit
19: mov ECX,10 ; iteration count (# of digits)
20: clc ; clear carry (we use ADC not ADD)
21: add_loop:
22: mov AL,[number1+ESI]
23: adc AL,[number2+ESI]
24: aaa ; ASCII adjust
25: pushf ; save flags because OR
26: or AL,30H ; changes CF that we need
27: popf ; in the next iteration
28: mov [sum+ESI],AL ; store the sum byte
29: dec ESI ; update ESI
30: loop add_loop
31: PutStr sum_msg ; display sum
32: PutStr sum
33: nwln
34: .EXIT
```

The program adds two numbers ```number1``` and ```number2``` and displays the sum. We use ESI as an index into the input numbers, which are in the ASCII representation. The ESI register is initialized to point to the rightmost digit (line 18). The loop count 10 is set up in ECX (line 19). The addition loop (lines 21–30) adds one digit by taking any carry generated by the previous iteration into account. This is done by using the ```adc``` rather than the ```add``` instruction. Since the ```adc``` instruction is used, we have to make sure that the carry is clear initially. This is done on line 20 using the ```clc``` (clear carry) instruction. Note that the ```aaa``` instruction produces the result in unpacked BCD form. To convert to
the ASCII form, we have to ```or``` the result with 30H (line 26). This ORing, however, destroys the carry generated by the ```adc``` instruction that we need in the next iteration. Therefore, it is necessary to save (line 25) and restore (line 27) the flags. The overhead in performing the addition is obvious. If the input numbers were in binary, only a single ```add``` instruction would have performed the required addition. This conversion overhead versus processing-overhead tradeoff is discussed in Section 11.4.